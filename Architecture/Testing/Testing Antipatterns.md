
1. Юнит-тесты без интеграционных
Любая работа с базой, триггеры, взаимодействие с апи требует интеграционных тестов.

2. Интеграционные тесты без модульных
Приложение должно иметь как unit, так и integrational тесты. 
Когда падают тесты обох типов вместе, первым делом нужно посмотреть юнит-тесты, ибо скорее всего из-за ошибки там не работают интеграционные.
Интеграционные тесты сложнее отлаживать и поддерживать. То, что модули работают правильно, ещё не означает, что правильно настроено и взаимодействие.

3. Неправильный тип тестов
Разные приложения требуют разное соотношение тестов. К примеру, где сложная логика приложения, но простая (либо отсутствует) бизнес логика, то должны преобладать интеграционные тесты, а где сложная бизнес логика, там unit-тесты. Приложения, назначение которых лежит в интерфейсе пользователя, должны иметь больше UI-тестов.

4. Неправильные приоритеты тестирования
Разный код имеет разную важность для конечного пользователя.

Нужно правильно расставить приоритеты тестирования:

1) Критически важный код. Он подвержен частым изменениям, добавлению нового функционала, максимально важен для пользователей.
2) Основной код. Небольшое кол-во важного для пользователей функционала, сбои не очень частые.
3) Другой код. Редко изменяется, минимальное влияние на пользователей.

5. Тестирование внутренней реализации
Симптом: при добавлении нового функционала требуется изменение множества тестов.
Тестировать нужно ожидаемое поведение, бизнес-требования, а не внутреннюю реализацию.
Нужно спросить себя: при данном тесте, елси изменится внутренняя реализация того или иного функционала, упадёт ли тест?

6. Чрезмерное внимание к code coverage
Code Coverage это не лучший показатель качества кода. Даже если код на 100% покрыт тестами, там всё равно могут жить баги. Скорее всего, 20% кода порождают 80% багов, а остальные 80% кода - всего лишь 20% багов.
Лучше всего протестировать базовый обязательный функционал (см. пункт 4).

7. Медленные или ненадёжные тесты
Если тест не детерминирован (иногда проходит, и иногда падает без изменений в коде), то это подрывает доверие в к тестам.
Build 1:
There are 2 flaky tests

Build 2:
Failed 2 tests (1 flacky and 1 not), won't we suppose that failed those flaky tests?

Нужно отделить такие тесты в отдельный набор. Если падает стабильный тест, это явно проблема с кодом. Если падает тест из набора flaky-тестов, то нужно перезапустить набор тестов.

8. Полуавтоматическое тестирование
Тесты должны выполнятся автоматически, то-есть без участия людей. В идеале - при каждом коммите или push.
Разработчик не должен каждый раз настраивать окружение для того, чтобы выполнить тесты.

9. Небрежное написание тестов
Тестам нужно уделять такое же внимание, как и основному коду. Код тестов должен быть чистым, т.к. мы должны его поддерживать.

10. Ненаписание тестов для новых багов, что приходят из production
Вся суть тестов - нахождение регрессий. 
Из production приходять именно критические для пользователя баги, которые скорее всего будут возобновлятся.
Для таких багов просто обязательно нужно писать тесты.
Все проблемы из production, для которых можно написать тест, должны иметь такой тест.

11. Отношение к TDD как к религии
Исходя из того, что не нужно писать тесты для примитивных частей кода, нам в данном случае не нужно использовать методику TDD.
Либо, когда мы не знаем какой функционал должен быть, а эксперементируем чтобы узнать (хотя, в данном случае лучше эксперементировать на отдельном проекте).

12. Незнание своей библиотеки
Прежде, чем писать тесты, лучше изучить фреймворк для тестирования, чтобы потом не пришлось избавляться от всяческих костылей.

13. Плохое отношение к тестированию по незнанию
Не нужно переставать писать тесты только потому, что в команде тесты подвержены антипаттернам. Нужно избавится от антипаттернов, а не от тестов.
Тесты позволяют отловить регрессии, и этим сказано всё.

