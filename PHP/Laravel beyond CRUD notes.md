## Domain oriented Laravel
The domain will hold classes like models, query builders, domain events, validation rules, etc.

The application layer will hold one or several applications (which don't talk one to another).

Structure example:

Domain:

```
app/Domain/Invoices/
    ├── Actions
    ├── QueryBuilders
    ├── Collections
    ├── DataTransferObjects
    ├── Events
    ├── Exceptions
    ├── Listeners
    ├── Models
    ├── Rules
    └── States
```

Application:

```
app/App/Api/
    ├── Controllers
    ├── Middlewares
    ├── Requests
    └── Resources
```

## Working with data

PHPStan (like an psalm), can be used to check php code for unobvious errors.

Associative Arrays are not the best way of storing data which isn't a collection of things. DTO is much more better, because we always know that expected data is present and has appropriate type.

For creating dto, we can use dedicated factory. The profit is on hand: when service needs some new argument in dto, all creational stuff is located inside factory. Thus, only 1 class has to be changed.

> Data transfer objects offer you a way to work with data in a structured, type safe and predictable way.


## Actions

Actions doesn't have to have abstractions or interfaces. They are like functions (take input, do something, give output).

Proc:
- Actions allow us to group our code by it's meaning rather than technical properties.
- they are reusable, and, thus, can be composed of other actions
- reduce cognitive load

## (Models)[https://stitcher.io/blog/laravel-beyond-crud-04-models]

Models are not place to place business logic.
All calculations should be done in actions, and if needed, results can be written to field of model

Ideally, inside models we only want to keep getters and setters, simple accessors and mutators, casts and relations.

For query scopes we can use dedicated Query Builder classes. In model we would need override `newEloquentBuilder()` method.
Likewise with collections.

> Domain model should guarantee invariants. It is not particularly possible with eloquent. 

## (States)[https://stitcher.io/blog/laravel-beyond-crud-05-states]

> If you find yourself writing class constants which names are same as values, probably there is a way for polymorphism.

State-dependant logic should be placed into separate state classes.

## (Managing Domains)[https://stitcher.io/blog/laravel-beyond-crud-06-managing-domains]

Before writing any code you should comprehensively understand problem you are about to solve.

In most cases we can easily refactor existing project to become domain-oriented. In PhpStorm place cursor on namespace or class to move folder or file.


## (Entering the application layer)[https://stitcher.io/blog/laravel-beyond-crud-07-entering-the-application-layer]

Group everything by real-world meaning rather than technical properties. Group together code that belongs together.

Thus, there is one place to go to know what code is available for you.

For general-purpose code, we can use `Support` namespace.

## (View models)[https://stitcher.io/blog/laravel-beyond-crud-08-view-models]

View models are classes especially for views.
We can implement `Responsable`, and return view with all required data needed. From controller we return just this ViewModel. Values passed to view should not be an business object. They should be primitive values (generated by presenters).

## (Test factories)[https://stitcher.io/blog/laravel-beyond-crud-09-test-factories]


Laravel factories have full support of model relationships. We can use `has` method and pass another factory.


