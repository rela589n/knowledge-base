# I - Внутренний механизм изменений в коде

## 1. Изменения в програмном коде

Причины:

1. Ввод свойства
Простое добавление програмного модуля не добавляет/изменяет поведение (если нигде не используется).

2. Исправление багов

3. Реорганизация (улучшение структуры)
Не предполагается никаких изменений функционала.

4. Оптимизация производительности

|-----------------------------------| Ввод свойства | Исправление бага | Рефакторинг | Оптимизация |
| Структура                         | +             | +                | +           | -           |
| Функциональные возможности (новые)| +             | -                | -           | -           |
| Функциональные возможности        | -             | +                | -           | -           |
| Использование ресурсов            | -             | -                | -           | +           |
|-----------------------------------|---------------|------------------|-------------|-------------|

При изменении кода:
- что мы должны изменить?
- как мы узнаем, что сделали всё правильно?
- как мы узнаем, что ничего не сломали?
- до какой степени мы можем изменять код, чтобы это не было очень рискованно?

## 2 - Работа с ответной реакцией

Изменения:

1. Правка наудачу;
2. Покрытие и модификация.

Регресии - изменения в коде.

Регресионное тестирование - тестирование, которое позволяет обнаруживать регресии.

Когда нам нужно внести изменения в некий модуль, мы должны сначала понять что он делает, и куда нам вносить изменения. Если код написан плохо, то пункт понимания занимает много времени. Но он должен быть выполнен каждым разработчиком, вносящим изменения в код. Поэтому, первый встретивший этот код разработчик, должен реорганизировать его для лучшего понимания. Но перед этим, модуль дожен быть максимально покрыт тестами.


Unit-тесты тестируют элементарные единицы поведения системы.

Unit-тесты позволяют быстро локализировать ошибки в коде.

Unit-тест, выполняющийся 0.1 секунды - это медленный тест.

Блочными тестами не являются:
- обращающийся к бд;
- работающие с сетью;
- работающие с файловой системой;
- для выполнения которых нужно настраивать среду;

### Тестовое покрытие

Если классы зависят от объектов, которые трудно протестировать, то изменить их будет трудно, и протестировать тем более.

Большая часть legacy требует разрывания зависимостей для упрощения изменений.


Если писать тесты для класса, не изменяя его, трудно, возможно будет проще написать тесты для класса, который использует его.


*Примитивизация параметра* и *Извлечение интерфейса* - безопасные реорганизации кода. Но нужно быть очень бдительным, потому как код ещё не покрыт тестами.

При разрыве зависимостей не стоит спешить с эстетичностью кода. Нужно понимать риск этой эстетичности на данном этапе.

### Алгоритм изменения legacy-кода

1. Определить точки нужных изменений;
2. Определить точки тестирования;
3. Разорвать зависимости;
4. Покрыть код тестами;
5. Внести изменения и отрефакторить.


> Код, который не зависит ни от чего, легко протестировать. Зависимости - помеха для тестирования. Ещё большей помехой являются неявные зависимости.


## 3. Распознавание и разделение

1. Распознование - разрываем зависимости, чтобы получить результат того, что делает код;
2. Разделение - разрываем зависимости, чтобы хоть как-то протестировать функционал;

Для распознования нужно иммитировать взаимодействующие объекты.


Фиктивные объекты всегда содержат 2 стороны:
- реализующий интерфейс;
- для тестирования.


## 4. Модель шва

Писать тесты во время разработки проще, чем писать их потом.

Шов - это место в коде, где может изменится функционал без изменения конкретно этого куска кода.

Каждый шов имеет разрешающую точку - место выбора того или иного поведения.

### Компоновочные швы

Это швы, которые получены в результате работы линкера. Компиляция - это не последний этап. В рантайме вызовы кода из других файлов разрешаются линкером.
Разрешение таких швов происходит установлением переменной среды `classpath` (в Java), а в PHP за импорт класса отвечает autoloader (можно зарегестрировать класс с помощью `spl_autoload_register`, что будет возвращать тестовую реализацию класса).

Компоновочные швы подходят как для разделения, так и для распознавания, поскольку теперь мы имеем контроль над кодом.


### Объектные швы

Такой шов базируется на явной зависимости на объектах. Когда объект передаётся как параметр, то это будет шов, поскольку мы можем передать любой объект.
В случае, если мы создаём конкретную реализацию и сразу же используем её, то здесь нету объектного шва.

Разрешающей точкой является список переданных методу параметров.

> По возможности лучше выбирать объектные швы, поскольку такие тесты проще поддерживать, нежели тесты с помощью компоновочных швов.


## 5. Инструментальные средства

Пользоваться рефакторингом, который предоставляет IDE стоит лишь в том случае, если это безопасно (не нарушится поведение -  к примеру, extract method не должен сработать, если уже существует метод с таким названием).



# II Изменения програмного обеспечения

## 6. Изменения необходимы, но на это нет времени

Когда нужно внести изменение, мы можем к примеру, написать тесты за 2 часа и внести изменения за 15 минут. Либо можем внести изменения за час без тестов.
Как показывает практика, написав тесты, мы более экономим в будущем, когда нам придётся вносить новые изменения либо просто для понимания кода с помощью тестов.

Код - это дом, в котором приходится жить разработчикам большую часть времени. Стоит держать его чистым.

### Почкование метода

Применять его стоит когда мы не можем протестировать исходный функционал, но его нужно изменить.

Зачастую если нам приходится вводить временную переменную, то это признак нарушения SRP.

Алгоритм:

1. Определить место изменений;
2. Определить, можно ли централизировать необходимую логику в отдельном месте;
3. Изменить исходный код таким образом, чтобы появились нужные далее локальные переменные;
4. Выяснить, нужно ли возвращать что-либо из необходимого модуля;
5. Разработать с помощью TDD отдельный модуль;
6. Добавить использование модуля в исходном коде.

### Почкование класса

Алгоритм

1. Определить место изменений;
2. Определить, можно ли централизировать необходимую логику в отдельном классе; Создать класс и метод, внедрить их использование в исходный код, после чего закомментировать эти строки кода.
3. Изменить исходный код таким образом, чтобы появились нужные далее локальные переменные;
4. Выяснить, нужно ли возвращать что-либо из необходимого модуля; если да, нужно добавить в новый класс метод для возврата этих значений;
5. Разработать с помощью TDD отдельный класс;
6. Добавить использование модуля в исходном коде посредством удаления комментариев с кода.

### Охват метода

Это приём, который предполагает вынесение старого кода полностью в новый метод, который будет вызван. Вместе з вызовом этого метода, можно добавить новую функциональность (в другом методе, который будет вызван).

С обратной стороны, можно оставить в покое изначальный метод, а создать новый, который будет его вызывать и добавит некоторый новый функционал.

Алгоритм:

1. Определить метод, который необходимо изменить;
2. Создать новый метод с таким же набором параметров, как оригинальный и перенести туда весь код оригинального метода;
3. Вызвать в оригинальном методе новый метод;
4. Добавить новое свойство посредством TDD.

### Охват класса

Это то же, что и декорирование. Часто, для этого нужно создать из существующего класса интерфейс, и сделать несколько реализаций. Одной из таких реализаций будет добавление нового функционала.


Иногда, декораторы добавляют некий overhead. Когда нам нужно только в часном случае добавить дополнительный функционал.
В таком случае можно просто обернуть нужный класс в псевдо-декораторе, который содержит логику и делегирует базовое выполнение декорируемому объекту. 
При желании можно также создать интерфейс, который свяжет эти два класса сигнатурой декорируемых методов.



## 7. Изменения до бесконечности


## 16. Код недостаточно понятен для его изменения

Для ввода нового свойства нужно понимать куда его нужно вводить.

### Составление примечаний и эскизов

Для хоть какого-либо понимания кода нужно составлять некие эскизы.
Сначала записываем имя последнего важного объекта, потом следующего. Если между ними есть связь, соединяем их линией.

> это отличный способ сохранить ясность ума при попытке понять что-либо сложное.

### Разметка листингов

Для применения этого способа необходимо сначала распечатать код


#### Разделение ответственности

Отмечаем код, который принадлежит к одной ответственности одним цветом, к другой - другим и т.д.

#### Уяснение структуры метода

Выравниваем код, смотрим на целую картину. В целом, IDE потдерживает скрытие логических блоков.

#### Извлечение методов

Для разделения большого метода на части, обводим часть, которую хотим вынести и помечаем код всязующим числом.

#### Уяснение воздействий в связи с изменением

Когда в код нужно внести изменение, то в этом месте помечаем все объекты, на которые может повлиять сделанное изменение.
Потом помечаем объекты на которые могут воздействовать помеченные объекты.


### Черновая реорганизация кода

Для лучшего понимания кода, можно его отрефакторить его в черновом варианте.
То-есть до начала рефакторинга мы сохраняем состояние кода в системе контроля версий, а после (когда мы уже в достаточной мере понимаем) - откатываемся.

> Этот способ не совсем безопасен, так как у нас может появиться неправильное представление о системе.

### Удаление ненужного кода

Если код очень запутан, и одна из его частей кажеться ненужной, то стоит просто удалить такой код. Он просто мешает. На случай, если он всё таки когда-либо понадобиться, то у нас есть система контроля версий.

> Можно также посмотреть на коммит, который добавил этот код. Если там много изменений, то вероятно автор мог просто забыть что эта часть ничего не делает.


## 17. У приложения отсутствует структура

.....
## 22. Необходимо изменить гигантский метод, но нельзя написать для него тест

Если доступно использование _безопасных_ средств реогранизации кода, то стоит пользоваться ими.
Но нужно делать только одно действие реорганизации в единицу времени. Иначе, велика вероятность принести ошибки в код.

После правок кода, должна появиться возможность расставить тесты по местам.

### Реорганизация вручную

#### Внедрение переменной распознавания

Когда мы не можем использовать автоматические средства, можно воспользоваться _переменной распознавания_.
Это означает, что перед извлечением метода, мы добавляем переменную класса, которая изменит значение в зависимости от выполнения извлечённого метода.
Написав тест, произведя рефакторинг, проверив что всё работает корректно, можно удалить _переменную распознавания_.

#### Извлечение того, что хорошо известно

Самое безопасное извлечение - это когда метод не принимает никаких параметров и ничего не возвращает. Его связующее число (к-во параметров и возвращаемых значений) равно 0.

Можно начать рефакторинг извлекая такие мелкие (~5 строк) методы с небольшим связующим числом.

#### Подбирание зависимостей

Когда мы выносим некую часть логики, которая не покрыта тестами вместе с покрытой логикой. Последняя будет служить полугарантией того, что зависимая логика не нарушена.
В данном случае, стоит писать тесты для основной логики.

#### Вынос объекта метода

Можно взять метод и полностью переместить его в отдельтую сущность, назвав его при этом `execute`. Локальные переменные станут полями класса, что даст возможность протестировать поведение.
Но это довольно радильная мера.


### Стратегии обращения с огромными методами

#### Скелетное представление методов

Условные конструкции `if` можно разбивать на 2 метода - условие и тело если это условие.
После вынесения в разные методы, в оригинальном остается только скелет.

#### Поиск последовательностей

Условные конструкции `if` можно выносить каждую отдельно в метод.
В результате в оригинальном методе останется последовательность вызовов методов.

Можно применять скелетное представление методов когда нужно будет рефакторить код после прояснения кода. А поиск последовательностей - когда это поможет прояснить код.


#### Извлечение в текущий класс

Иногда может возникнуть искушение выносить методы в отдельный класс. Например, когда мы называем метод с частью названия переменной (как `orderNeedsReevaluation`). 
Но это делать не рекомендуется, так как это мы всегда успеем сделать, а на данном этапе рефакторинга нужно, чтобы все изменения были легко отменяемыми.


#### Готовность к повторному извлечению

Иногда после извлечения нескольких методов, нам стоит отменить предыдущие извлечения методов. Но это не означает, что это была пустая трата времени, так как теперь мы лучше понимаем код и пути его реорганизации.


------ 22 --------

## 23. Как узнать, нарушают ли что-нибудь изменения в коде

> Если не трогать код, он никогда не разрушится (в отличие от физических материалов как металл, и т.д.)
> Поэтому мы сами - источники збоев в коде.


### Сверхосторожная правка

### Правка с единственной целью

> Главный навык программирования - рассудительность

> Программирование - это искусство делать всё по порядку

Стоит делать только одну задачу в один момент времени. Так просто эффективнее.

Можно очень легко потратить немало времени и сил, просто пытаясь сделать код работоспособным.
Лучше же действовать обдуманно, хорошо понимая что именно делает код.

### Сохранение сигнатур

Разрывая зависимости для тестирования кода следует быть особенно осторожным.

Сохранение сигнатур предполагает полное копирование и вставку целых сигнатур методов по возможности без их изменения.
Мы просто копируем параметры сигнатуры 

### Упор на компилятор:

1. Изменение в объявлении, чтобы вызвать ошибки компиляции;
2. Последовательное исправление этих ошибок компиляции.

> можно попробовать использовать этот подход и в PHP. Но для этого нужен статический анализатор кода (как psalm)

Для использования этого инструмента, стоит чётко понимать границы того, что может выявить компилятор.


### Парное программирование

Когда делаем изменения, требующие большой точности, то можно прибегнуть к парному программированию.
Так, когда мы могли б совершить ошибку, наш коллега подскажет нам это.

## 24. Сдаёмся - дальнейшее улучшение невозможно


# III - Методы разрыва зависимостей

## 25. Способы разрыва зависимостей

Эти способы предназначены для рефакторинга без _тестов_.


### Адаптация параметра


Когда метод зависит от деталей реализации, когда нам сложно проверть взаимодействие метода на входящие параметры либо же сложно добавить новый параметр, применяется адаптация параметра.
К примеру, в случае если сервис зависит от объетка конкретного Request, а нам нужно каким-то образом протестировать, в данном случае мы просто не можем извлечь интерфейс, а даже если можем, то это в любом случае даст сложности при тестировании.


Использовать адаптацию параметра следует очень осторожно, так как изменяется сигнатура метода.
Следует предпочитать те изменения которые безопасны, а не те, которые делают структуру кода еще лучше.

> После адаптации параметра, стоит протестировать что функционал работает корректно

Итого:

1. Создаём самый простой интерфейс, что будет использоваться в методе. Он не должен требовать многих изменений в исходном коде;
2. Создаём средство реализации этого интерфейса в исходном коде;
3. Создаём тестовую реализацию;
4. Пишем тест, передая фиктивный объект;
5. Изменяем метод, чтобы соответствовать ожиданиям теста;
6. Выполняем тест, удостоверившись в корректности проделанной работы.


### Вынос объекта метода

> Используется в случае когда невозможно протестировать функционал из-за зависимостей класса, которые нужно создать.

Если метод не использует переменные и методы класса, можно применить *раскрытие статического метода*. Иначе, применяется этот подход.


В худшем случае у нас будут зависимости на переменные и методы исходного класса.

Тогда, мы передаём исходный объект из которого выносим метод в экземпляр класса, и из private делаем public.

Также, все параметры метода должны стать полями класса, а сам метод будет не иметь аргументов.


Итого:
1. Создаём новый клас, который будет содержать метод;
2. В конструкторе принимаем те же параметры, что и параметры метода (используем сохранение сигнатур);
3. Копируем тело метода из исходного класса в новый;
4. Проходимся по местах, где использовались параметры метода и заменяем их полями объекта;
5. Если есть обращения к методам (используя $this), то нужно добавить в поле исходный объект;
6. Если методы, от которых мы зависим, используються только для этого метода, то просто переносим их в новый класс;
6. Проходимся по местах, где есть обращения к методам и меняем $this на исходный объект;
7. В месте старого метода создаём новый объект и вызываем его метод;
8. Используем _извлечение интерфейса_ для того, чтобы сделать новый класс тестируемым.


### Расширение определения

Использует компоновочный шов, стоит использовать только в крайних случаях.


### Инкапсуляция глобальных ссылок

.....


### Раскрытие статического метода

В случае когда создать экземпляр очень трудно или невозможно.

Если метод не использует поля и методы экземпляра, то можно сделать его статическим и общедоступным чтобы протестировать. Или же, мы можем добавить новый статический метод, в который полностью перенесём тело исходного метода.

Если мы не хотим делать метод общедоступным, то можно сделать его защищённым и обращаться к нему с помощью тестирующего подкласса.

#### Процедура

1. Пишем тест для метода, который нужно раскрыть.
2. Извлекаем тело метода в статический, сохраняя при этом сигнатуры. Для названия, можно воспользоваться частью параметров.
3. Компилируем
4. Смотрим, есть ли ошибки, связанные с доступом к полям или методам экземпляра. Если возможно, их также делаем статическими.

### Извлечение и переопределение вызова

Когда код использует вызов статического метода либо глобальной функции, а нам нужно изменить это поведение для тестирования, то можно делегировать вызов этого глобального объекта локальному методу этого класса (именно его мы будем переопределять).

#### Процедура

1. Находим вызов, который нужно извлечь
2. Создаём локальный метода в текущем классе с идентичной сигнатурой
3. Копируем исходный вызов в локальный метод, не забываем возвратить значение
4. Заменяем исходный вызов локальным методом
5. Создаём тестирующий подкласс и переопределяем новый метод
 
### Извлечение и переопределение фабричного метода

Когда в конструкторе класса создаётся некий набор объектов, которые нам нужно заменить при тестировании

#### Процедура

1. Определить код создания объекта, который нужно заменить при тестировании;
2. Извлечь всю эту логику в фабричный метод;
3. Создаём тестирующий подкласс, что определяет логику создания тестового объекта.

### Извлечение и переопределение получателя

Применяеться когда невозможно "извлечение и переопределение фабричного метода" (к примеру, в C++ нельзя вызывать виртуальный метод в конструкторе).
Заключаеться в замене доступа к объекту через поле на вызов метода, который lazy-создаст и будет возвращать это поле.

> После применения этой процедуры, стоит уделить должное внимание сборке мусора

#### Процедура

1. Выявляем объект, для которого нужен геттер;
2. Извлекаем всю логику инициализации поля в метод-получатель;
3. В конструкторе полю присваиваем пустоее значение;
4. Добавляем в метод логику первого вызова;
5. Заменяем все прямые доступы к полю вызовами метода;
6. Создаём тестовый подкласс и переопределяем получателя.

### Извлечение средства реализации

Состоит в превращении класса в интерфейс, перенося все его реализации методов в подкласс.

#### Процедура

1. Создаём копию класса, присвоив ему новое имя;
2. Делаем из исходного класса интерфейсс;
3. Удаляем ненужные импорты из файла интерфейса;
4. Имплементируем созданный интерфейс новой реализацией;
5. На всех местах, что содержат создание уже интерфейса, заменяем на логику создания подкласса;
6. Проводим тестирование кода.





