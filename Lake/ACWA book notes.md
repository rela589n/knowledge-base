## Bad habits:

1. Violation SRP

2. CRUD mindset

3. Magic PHP
Прежде всего нужно думать о поддержке кода. Если его было сложно писать, скорее всего, будет сложно и потдерживать

4. Rapid App Dev

Implicit route binding - плохая идея. Это "неявно". Код должен быть явным, чтобы можно было легко потдерживать его.

Не стоит реализовывать действие и обратное ему в том же методе. Во-первых, это плохо сказывается на читабельности кода, а во-вторых, при race-condition будут проблемы (двое клиентов хотят выполнить действие, а в результате первый выполняет, а второй - отменяет)


## DI:

1. SRP

Сильная связанность может привести к каскаду изменений в коде, поскольку модули знают слишком многое один про другого.

2. DI

DI - И детали, и абстракции должны зависеть от абстракций.

Имя интерфейса не должно показывать что это интерфейс. Это должно быть естественное имя.

3. Inheritance

Если есть интерфейс и одна реализация, то интерфейс не нужно создавать. Можно напрямую внедрять класс. Потом уже (если будет нужно), создадим интерфейс.

Клас, который не является `final`, имеет 2 ответственности: 
-  Перед своими клиентами 
-  Перед наследниками

4. Пример с картинками

Вместо параметров с дискретным набором возможно стоит использовать полиморфизм. К примеру, для булевых параметров.

Либо вынести это в конфигурацию. Вместо "Фасада" `Config`, стоит использовать `Illuminate\Contracts\Config\Repository`.

5. Расширение интерфейсов

Использование наследования для того, чтобы унаследовать функционал — очень плохая идея. Когда нужно будет добавить какой-либо еще функционал, то придётся изменить все дочерние классы, чтобы передать параметры в `parent::__construct`.

Стоит создать отдельный интерфейс (при необходимости уже его наследовать от интерфейса фреймворка). И реализацию-декоратор, которая будет использовать фреймворк в своих целях.

6. Трейты

Использование трейтов делает много предположений. Это делает их использование очень хрупким.

Не стоит использовать трейты как `partial classes`, потому что когда возникает такое желание, это обозначает что класс имеет слишком много ответственностей. Так, лучше создать отдельные классы вместо трейтов и использовать этот класс как комбинацию их ответственностей.

7. Статические методы
Это жёсткая связь.
Ключи для кеширования тоже должны быть жёсткими, поэтому - нормальный use-case.
Можно использовать статические методы для внутренних зависимостей, которые не работают с внешним миром.


## Refactor

1. Статическая типизация

Для безболезненного рефакторинга нужно сделать код как можно более статичным.

2. Views

PhpDocs можно и стоит также писать в шаблонах.

3. Поля моделей

Стоит использовать barryvdh/laravel-ide-helper для генерации phpdocs для виртуальных полей моделей.

4. Laravel Idea

Плагин для PhpStorm для прекрасной работы с laravel.


## Application Layer

Нужно разделять слой интерфейсов и БЛ приложения.

### 1. Передача данных
Для передачи данных стоит использовать DTO.

### 2. Работа с БД

Не стоит делать выборку сущностей прямо в контроллере. Нужно опубликовать пост? Тогда лучше передать сервису его `$id`. В любом случае нужно будет делать выборку из базы. Почему бы не сделать это в сервисе? Так мы получаем контроль над выборкой, и можем изменить это при необходимости в будущем.

### 3. Services vs Commands

Лучше использовать классы команд, чтобы не загромождать сервисы излишними неиспользуемыми зависимостсями.

## Exceptions

Любая негативная ситуация - Exception

Стоит создать базовый `BusinessException`, что будет представлять ошибки бизнес-логики.


Дальше в глобальном обработчике исключений, мы можем проверить `$e instanceof BusinessException`, и сгенерировать соответствующий результат для клиента. Либо залогировать исключение.

Стоит использовать непроверяемые исключения так как они не требуют объявления в сигнатуре. Когда нужно будет выбросить какое-либо ещё исключение, мы избежим каскада изменений сигнатур.

## Validation

Для каждого внешнего интерфейса должна быть базовая валидация. Никаких `exists:categories,id,deleted_at,null` не может быть. 

Валидация, связанная с базой данных должна производиться на уровне приложения.


DTO - не место для валидации. Может быть несколько DTO-классов, которые используют те же параметры (к примеру, имя пользователя). Тогда придётся дублировать всё это.

В DTO можно использовать ValueObjects, чтобы не было излишнее количество полей.

DTO - не лучшее место для валидации, потому что данные, которые пришли в слой приложения не всегда те же, что отправил пользователь. Они могут быть взяты из какого-либо api, и пользователь увидит ошибку про данные, которые не вводил. К примеру, при выборке из базы, была попытка создать модель с невалидным email. А пользователь то не вводил никакого email.

InvalidArgumentException наследуется от LogicException. Когда мы видим исключение типа LogicException, значит в коде ошибка, которую нужно срочно исправить.

## Events

### 1. DB transactions

Транзакции должны быть максимально простыми (просто создание моделей из примитивных данных) и сохранение. Все вызовы api и другие тяжёлые операции должны быть выполнены до транзакции.

### 2. Очереди

Для тяжёлых задач стоит создать Job-классы, выполнение которых можно положить в очередь.

### 3. События

Не стоит использовать Eloquent-события для построения бизнес-логики. Как минимум, потому что когда queue-driver установлен в sync, то транзакции будут выполнятся очень долго (из-за пост-действий).

А также, не будет сгенерировано никаких событий при использовании mass-insert и mass-delete.

Не стоит передавать Eloqeunt-сущности в объекты событий, поскольку могут быть проблемы с relations (загружена старая версия данных). Да, можно явно вызвать метод `load()`, но всё это делает код хрупким. Лучше использовать `id`.


## Testing
Хорошая привычка: если найден баг, надо написать тест, который его воспроизведет и упадёт.

Когда класс зависит от другого класса (не от интерфейса), и зависимый класс не может существовать вне первого, не нужно прописывать его как зависимость конструктора. Можно просто создать его внутри конструктора.

Тесты должны работать снаружи, "как будто клиентский код это использует", они не должны лезть внутрь приложения. К примеру, тест api создания пользователя не проверяет наличие в базе, а делает еще GET запрос на выборку из api и проверяет результат.

Проблема использования Laravel-фасадов (в часности, при тестировании), заключается в том, что сам класс не объявляет явно что ему нужно для правильной работы. А тест, напротив должен заменить все используемые фасады на моки. Это может привести к проблемам, когда будет добавлен вызов нового фасада, а в тестах забудут поправить. Тогда могут происходить реальные вызовы апи, если не что-то хуже.

> Все зависимости должны быть явными!

Вместо лара-фасадов, лучше использовать реальные классы, что работают под капотом. Так можно будет покрыть код юнит-тестами.

## Domain layer

Вынесение бизнес-логики в отдельный слой чуть ли не обязательно для приложений, в которой БЛ сложнее за логику приложения.

Критерии отделения бизнес-логики:

- Unit-тесты. Когда БЛ сложная, модульных тестов должно быть много, т.к. они выполняются быстро, а функциональных - немного, т.к. они долгие, и мы не можем на каждый чих запускать их.
- Простота поддержки кода. Ну нужно держать сущность и базу данных в голове одновременно.
- Active Record vs Data Mapper:
 Высокая связность бизнес-логики
 Сдвиг фокуса с БД на предметную область
 Сдвиг фокуса с пользовательского интерфейса к предметной области
 Инварианты сущностей

В Eloquent все объекты формально независимы, что делает сложным поддержание инвариантов.

Стоит избавиться от геттеров в VO. Для сохранения в БД (при использовании Eloquent), можно использовать `$vo->toArray()`.

При отделении Доменного слоя от всего остального, мы вынуждены использовать идентификатор, который можем создать заранее. Это может быть, к примеру uuid.

Не стоит делать DDD для простых приложений.

## CQRS

## Event Sourcing

