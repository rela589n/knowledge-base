
Интерфейсы нужно именовать естественным образом (без префиксов или суффиксов) - можно будет при необходимости сделать их абстрактными классами,
а реализации - в соответствии с тем, что они делают.

Если есть интерфейс и одна реализация, а другую реализацию сложно представить, 
то в этом случае интерфейс не нужен, можно просто использоватькласс с естественным именем

Не нужно излишне использовать магию php.

Use Composition over inheritance где это возможно.

Использование в Laravel route bindings - плохой тон.
Когда нужно будет внедрять кеширование, придётся именовать параметры
особым образом для того, чтобы это работало. Да, и это не очевидно.

Булевы (и не только) параметры методов можно (и нужно) заменить на полиморфизм.
Для этого просто нужно создать отдельный класс для каждой ветки. А принимать интерфейс.
Любой параметр, что порождает условные операторы нужно заменить полиморфизмом.
<=>
Иным же способом решения этой проблемы есть создание файла конфигурации.
В самом методе избавляемся от лишних параметров, и используем конфиги.

Трейты - это зло. Они делают код неочевидным.
Лучше использовать Dependency Injection вместо.
Разработчики используют трейты по двум причинам:
1) создавая архитектурные проблемы (иногда не осознавая этого);
2) борясь с последствиями архитектурных проблем.

Статические методы лучше в большинстве случаев не использовать.
Использование статических методов для таких внутренних зависимостей,
которые не работают с внешним миром (файлами, БД или API) — нормальная практика.
Например, генерация ключей кеширования - вряд ли будет ещё один возможный метод генерации 
ключей кеширования. Статические методы можно использовать там, где обычно захардкодил какое-нть
значение, используемое только для внутреннего взаимодействия в программе. Но лучше это вынести в отдельное место.

IDE должна знать все про каждый метод и каждое поле, которое я использую.
Если функция возвращает объект какого-то класса, он должен быть объявленкак return-тип.
phpdoc должен быть везде, где не подсказывает ide.


5. Слой приложения - то же, что и сервисный слой. В GRASP этот слой называется Слой контроллеров(Controllers layer).
Может быть несколько возможных вариантов приложения - веб, под мобильный, телеграм-бот и т. д.
Вся логика приложения должна предоставляться с помощью сервисных классов.

6. Обработка ошибок.
Можно использовать эдакой класс FunctionResult, который содержит
такие поля: $success, $returnValue, $errorMessage. 
Успешный ответ FunctionResult::success($return)
Неуспешный ответ: FunctionResult::success($errorMessage)

Есть 2 типа исключений:
1) Проверяемые (Throwable, Exception) - обязаны быть пойманы или объявлены в сигнатуре
2) Непроверяемые (Error, RuntimeException, LogicException) - могут быть выброшены без всяких дополнительных условий

Вызывающий код может что-то сделать с проверяемыми исключениями и эта строгость обязывает его сделать это.
(Все это приводит к болеекорректной обработке ошибок).
Но laravel-овский ModelNotFoundException унаследован от RuntimeException (непроверяемый по умолчанию).

То-есть, если exception должен быть обработан в ExceptionHandler-е, то можно наследоваться от RuntimeException.

7. Валидация:
1) валидация аннотациями symfony/validator.
Просто добавляем аннотации для дто.
Но есть проблема, что данные, передаваемые от пользователя не всегда равны данным, передаваемым в слой приложения.
Value-Objects должны иметь собственную валидацию (чтобы убедиться в корректности (уже провалидированных) данных), но это не единственная.

8. События (Правило прокрастинатора: если что-то можно отложить, это надо отложить.)

При создании сущности вместе с её дочерними, когда есть ограничения на дочерние
(Ну и в принципе, когда идёт создание нескольких вещей за раз), стоит использовать транзакции базы данных.

При этом, они должны выполнятся как можно быстрее (никаких вызовов сторонних либ, API и т. д.) - в транзакции работа только с готовыми данными.
Никогда не стоит использовать события Eloquent для организации бизнес-логики. Например, транзакция не была успешной, а событие уже сгенерировано.

Сервис должен выполнять только своё основное действие. Для всех остальных действий - генерируем событие. 
Но ни в коем случае нельзя генерировать событие внутри транзакции.
Все сложные действия, которые можно отложить, нужно отложить в очередь.

Не стоит передавать Eloquent-модели как поля классов-событий (могут быть проблемы с отношениями (устарелая информация)).
Лучше передать id и сделать лишний запрос в БД.

9. Unit-тестирование.
Когда найден баг в коде, нужно написать тест, который споткнётся об него, а уже потом исправлять его.
(Нам всё равно нужно будет проверить, исправлен он или нет)
Тесты обычно падают в крайних местах.

При рефакторинге кода, стоит сразу же запускать тесты, чтобы проверить, не сломалось ли что-небудь.
Написание тестом для классов: Arrange, Act, Assert (AAA)

Если класс не есть внешней зависимостью (а скорее, частью данного модуля), то стоит принимать его параметром 
через конструктор, а просто создать его внутри.
Когда методы класса полностью независимы друг от друга, класс не является модулем (он имеет низкий уровень cohesion).

Все зависимости класса нужно мокать.
Не стоит тестировать методом белого ящика (анализировать какие методы, сколько раз были вызваны внутри).

Типы тестов ПО:
1) Unit-тестирование (тестирует модули в изоляции);
2) Интеграционное тестирование (проверяет совместную работу нескольких модулей);
3) Функциональное тестирование (e2e end to end) - проверяет приложение на соответствие функциональным требованиям;

Laravel-фасады - зло для тестирования. Они приносят уйму неявных зависимостей. Стоит их избегать.
Лучше все зависимости сделать явными.
Наследуемся только от \PHPUnit\Framework\TestCase , ни в коем случае не от ларавеловского, потому что он дополнительно подстраивает окружение.

Если код сложно тестировать, скорее всего он обладает высокой связанностью.
Писать unit-тесты для слоя приложения - очень трудно и не очень полезно

10. Доменный слой
Если приложение - простой CRUD с очень небольшойдополнительной логикой, от доменного слоя будет мало толку

Domain logic - логика, которую представляют себе пользователи или заказчики.
ActiveRecord содержит сразу две логики - логика работы с базой и бизнес-логика. Это нарушает SRP.

Реализация логики в методах отдельных сервисных классов приведёт к невероятному дублированию кода 
и лучший способ это дублирование устранить - сконцентрировать логику в сущностях внутри единого модуля.
 
Инвариант класса, это условие на его состояние, которое должно выполняться всегда.
В сущностях Eloquent крайне трудно обеспечивать инварианты. В итоге все инварианты Eloquent сущностей держатся буквально на честном слове.

Анемичная модель - когда сущности только хранят данные, а работают сними другие классы.
Богатая модель - сама работает сосвоими данными.

Бизнес-логика должна быть реализована без использования геттеров и сеттеров. Это позволяет легко сохранять инварианты.
События бизнес-логики должны генерироваться в именованных конструкторах (да, их может быть несколько).

Для маппинга моделей в БД лучше всего подойдёт  laravel-doctrine/orm 
Конфиги можно прописать как в отдельном файле, так и с помощью аннотаций.

То-есть при таком маппинге объектов в базу данных, мы можем создавать их без оглядки на БД.
Потдерживаеся использование value-objects. При выборе из бд будет использована рефлексия, то-есть конструктор вызван не будет.
Поэтому жизненный цикл всех объектов - естественный.

Ошибки можно обрабатывать при помощи исключений (уже проверяемые) или при помощи FunctionResult 
(если нужно собрать все ошибки, то от исключений не будет много толку).

11. CQRS (Command Query Responsibility Segregation)
Чтение и запись - разные ответственности.

Database views - виртуальные таблицы, которые построены на основе запросов.
Master-slave replication - все изменения идут на мастер базу данных и реплицируются на слейв базы данных, которые называются репликами.
(write-запросы идут водно место, read-запросы в другое)
https://www.toptal.com/mysql/mysql-master-slave-replication-tutorial

Архитектура с разными хранилищами для записи ичтения имеет тип консистентности eventual consistency.

Если кеширование реализовать прямо в классе сервиса, то у него будут как минимум две ответственности: работа с базой данных и кеширование. 
Лучшее решение - шаблон Proxy (или декоратор).
Создаём интерфейс репозитория для сущности, реализуем Database implementation и Cached Implementaion (тот самый декоратор). 
Но весь код должен быть привязан к интерфейсу.

CQRS - создаём 2 модели - одна для чтения, другая - для записи.
Можно чтение, например, реализовать с помощью Eloquent, а запись - Doctrine.

Это полезно для производительности, распредения нагрузки,
но при изменении структуры бд - нужно будет менять в двух местах - read и write модель.

12. Event sourcing (этот шаблон предлагает хранить все изменения в системе как последовательность событий)
Там, где бизнес-логика требует знание о том, что было ранее, нужно хранить не состояние на поточный момент времени,
а всю историю изменений. Когда нужно получить текущее состояние - просто применяем все изменения.

Юнит-тесты, которые основаны только на событиях, сгенерированных классом, не всегда гарантируют правильность.

В качестве оптимизации, можно историю изменений хранить в write-storage, а  текущее состояние в read-storage.
Таблица с событиями имеет только 2 действия - read & insert.

Можно использовать разные Uuid для каждой сущности. Для этого просто нужно для каждой из них создать свой класс, содержащий uuid.
Это гарантирует, что при поиске сущности с помощью идентификатора другой, не будет найдена никакая информация.

Проекции - это объекты, которые трансформируют ES-события в данные, удобные для чтения.
У нас есть read-model, которая работает с БД. Там храняться сущности в данный момент временти.
При наступлении события бизнес-логики, нужно обновить данные сущности в соответствии с этим событием.

ES-системы имеют проблемы с уникальностью данных, так как сущности абсолютно независимы одна от другой.
Можно использовать индексы для таблиц чтения, но это не даёт 100 % гарантии.
Другой вариант - создать таблицу, которая будет содержать одно уникальное поле под индексом и вставлять туда значение перед попыткой сохранить событие.
